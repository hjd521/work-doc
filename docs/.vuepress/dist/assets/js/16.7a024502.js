(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{215:function(e,t,s){"use strict";s.r(t);var n=s(28),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"实现promise中的then方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现promise中的then方法"}},[e._v("#")]),e._v(" 实现promise中的then方法")]),e._v(" "),s("h3",{attrs:{id:"功能总结："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#功能总结："}},[e._v("#")]),e._v(" 功能总结：")]),e._v(" "),s("ul",[s("li",[e._v("reslove调用时候执行then绑定的方法。")]),e._v(" "),s("li",[e._v("支持成功回调和失败回调的参数传入。")]),e._v(" "),s("li",[e._v("在promise的状态固定了之后就不能再改变，会立即在下一个tick执行。")]),e._v(" "),s("li",[e._v("如何支持链式调用？返回一个新的promise.")])]),e._v(" "),s("h4",{attrs:{id:"实现步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现步骤"}},[e._v("#")]),e._v(" 实现步骤")]),e._v(" "),s("ol",[s("li",[e._v("定义一个新的promise实例并且返回，实现链式调用的功能。")]),e._v(" "),s("li",[e._v("参数标准化，对then中的两个参数进行默认值设置。")]),e._v(" "),s("li",[e._v("判断promise的内部状态status")]),e._v(" "),s("li",[e._v("如果为pending，那么添加回调函数到对应的成功或者失败数组中。")]),e._v(" "),s("li",[e._v("并且利用try catch防止代码报错。")]),e._v(" "),s("li",[e._v("利用resolvePromise来处理回调的结果，以为后边的链式调用提供resolve值")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  then(sucBack, failBack) {\n    let self = this\n    let promise2 = new Promise((resolve, reject) => {\n      if (!sucBack) {\n        subBack  = (val) => {\n          return val\n        }\n    }\n    if (!failBack) {\n      failBack = (val) => {\n        return val\n      }\n    }\n    if (this.status = status.fullfilled) {\n      setTimeout(() => {\n        try {\n          let x = sucBack(this.value)\n          resolvePromise(promise2,x resolve,reject)\n        } catch((err) => {\n          reject(err)\n        })\n      },0)\n    }\n    if (this.status = status.failed) {\n      setTimeout(() => {\n        try {\n          let x = failBack(this.reason)\n          resolvePromise(promise2,x resolve,reject)\n        } catch((err) => {\n          reject(err)\n        })\n      },0)\n    }\n    if (this.status = status.pending) {\n      this.fullfills.push(function() {\n        setTimeout(() => {\n          sucBack(self.reason)\n        }, 0)\n      })\n      this.fails.push(function() {\n        setTimeout(() => {\n         try {\n          let x = sucBack(this.value)\n          resolvePromise(promise2,x resolve,reject)\n        } catch((err) => {\n          reject(err)\n        })\n        }, 0)\n      })\n    }\n    })\n    return promise2\n  }\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);