(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{224:function(e,n,t){"use strict";t.r(n);var l=t(28),s=Object(l.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"webpack运行流程说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack运行流程说明"}},[e._v("#")]),e._v(" webpack运行流程说明")]),e._v(" "),t("ol",[t("li",[e._v("从命令行参数以及配置文件中拿到webpack的运行参数与默认参数进行合并生成最终的参数配置。")]),e._v(" "),t("li",[e._v("调用compiler类。")]),e._v(" "),t("li",[e._v("注册webpack的plugin")]),e._v(" "),t("li",[e._v("执行compiler的run方法进行编译")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  let Compiler = require('compiler')\n  function webpack(options) {\n    let argv = process.argv.slice(2)\n    let shellOptions = argv.reduce((config, cur) => {\n      let [key,value] = cur.split('=')\n      config[key] = value\n    }, {})\n    let finalOptions = { ...options, ...shellOptions } // 拿到最终的参数结果。\n    let compiler = new Compiler(finalOptions)\n    // chuli\n    for (let plugin in options.pllugins) {\n      plugin.apply(compiler)\n    }\n    copmpiler.run()\n  }\n")])])]),t("ol",{attrs:{start:"5"}},[t("li",[e._v("compiler类注册tapable钩子，用来通知插件在特定的时间点做对应的事情。")]),e._v(" "),t("li",[e._v("执行compiler的compile方法执行compilation类执行build方法进行具体的构建，并且在回调中将文件输出到dist文件。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  let { SyncHook } = require("tapable");\n  let fs = require("fs");\n  let path = require("path");\n  let Complication = require("./Complication");\n  class Compiler {\n    constructor() {\n      this.options = options;\n      this.hooks = {\n        run: new SyncHook(), //会在开始编译的时候触发\n        done: new SyncHook(), //会在结束编译的时候触发\n      }\n    }\n    run(callback) {\n      let onCompiled = function(err, states) {\n        if(err) {\n          console.log(err)\n        } else {\n          // 将代码输出到dist文件夹下\n        }\n      }\n      this.compile(onCompiled)\n    }\n    compile(callback) {\n      let complication = new Complication(this.options);\n      complication.build(callback);\n    }\n  }\n')])])]),t("ol",{attrs:{start:"7"}},[t("li",[e._v("complication执行build从entry入口查找文件执行loaders进行转换。")]),e._v(" "),t("li",[e._v("找到模块的导入语句进行ast分析，将引入的依赖的模块放到本模块的依赖数组中。并且每个模块都赋值三个属性，id(path路径)，name(入口模块), dependencies(依赖的模块)")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let types = require("babel-types");\nlet parser = require("@babel/parser");\nlet traverse = require("@babel/traverse").default;\nlet generator = require("@babel/generator").default;\nlet dirPath = toUnixPath(process.pwd())\nfunction toUnixPath(path) {\n  return path.replace(/\\\\/g, \'/\')\n}\nclass Complication {\n  constructor() {\n    constructor(options) {\n      this.options = options;\n      this.modules = []; //存放着本次编译生产所有的模块 所有的入口产出的模块\n      this.chunks = []; //代码块的数组\n      this.assets = {}; //产出的资源\n      this.fileDependencies = [];\n    }\n  },\n  // build，根据entry开始构建流程\n  build(callback) {\n    let entryConfig = this.options.entry\n    let entry = {}\n    if (typeof entry === \'string\') {\n      entry.main = entryConfig\n    } else {\n      entry = entryConfig\n    }\n    for (let key in entry) {\n      let filePath = entry[key]\n      // 拿到入口文件的真实路径\n      let entryFilePath = path.posix.join(dirPath, filePath)\n      let entryModule = this.buildModule(key, entryFilePath) // 入口模块的key以及相应的绝对路径，最终将所有模块转换完毕之后都放入modules数组中，且有唯一的入口表示name：代表从哪个entry中构建的。将来方便生成代码\n      //生成chunk-根据入口名称以及modules中的name对应，构建chunk: {name, entryModule, modules}\n      let chunk = {\n        name: entryName,\n        entryModule,\n        modules: this.modules.map((item) => {return item.name === entryName})\n      }\n      this.chunks.push(chunk);\n    }\n    // 再根据chunks构建输出到文件的真实资源放到assets中{fileName: 代码资源}\n    this.chunks.forEach((chunk) => {\n      let filename = this.options.output.filename.replace("[name]", chunk.name);\n      this.assets[filename] = getSource(chunk);\n    });\n    callback(null,  {\n        chunks: this.chunks,\n        modules: this.modules,\n        assets: this.assets,\n      },)\n  }\n  // 调用loader转换代码\n    // 利用ast分析依赖循环遍历\n    // 遍历依赖递归执行buildModule\n    buildModule(entryName, modulePath) {\n      let loaders = []\n      let sourceCode = fs.readFileSync(modulePath, "utf8")\n      let sourceCode\n      for (let loader in this.options.module.rules) {\n        if (loader.test.test(entryPath)) {\n          loaders.push(loader.use)\n        }\n      }\n      for (let i = loaders.length-1; i>= 0;i++) {\n        sourceCode = require(loader)(sourceCode)\n      }\n      let moduleId = "./" + path.posix.relative(dirPath, modulePath)\n      let module = {name: entryName, dependencies: [], moduleId}\n      let ast = parser.parse(sourceCode, { sourceType: "module" })\n      traverse(ast, {\n        \'CallExpression\': function ({node}) {\n           if (node.callee === \'require\') {\n             let depModuleName = node.arguments[0].value\n             let dirname = path.posix.dirname(modulePath)\n           }\n        }\n      })\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);