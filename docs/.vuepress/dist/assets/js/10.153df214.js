(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{209:function(t,a,e){"use strict";e.r(a);var s=e(28),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"async的基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async的基本概念"}},[t._v("#")]),t._v(" async的基本概念")]),t._v(" "),e("ul",[e("li",[t._v("async函数返回一个promise对象，可以用then接收。当函数运行中，一旦遇到await就会先返回，等到异步操作完成，再接着往下继续执行。")]),t._v(" "),e("li",[t._v("async函数内部return命令返回的值，会被then方法回调函数接收到。")]),t._v(" "),e("li",[t._v("async函数内部的错误会被catch方法接收到。")])]),t._v(" "),e("h3",{attrs:{id:"await命令基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#await命令基本概念"}},[t._v("#")]),t._v(" await命令基本概念")]),t._v(" "),e("ul",[e("li",[t._v("await后边跟着一个promise对象，返回该对象的结果。如果不是promise对象直接返回对应的值。")]),t._v(" "),e("li",[t._v("await后边的promise如果变为reject状态，则reject的参数会给async函数的catch接收，且没做try catch情况下会直接退出async函数。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  // 实现休眠效果,让语句5s后才执行。\n  function sleep(time) {\n    return new Promise((resolve) => {\n      setTimeout(resolve, time)\n    })\n  }\n  async run() {\n    await sleep(5000)\n    console.log(666)\n  }\n  sleep()\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);