(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{210:function(e,t,r){"use strict";r.r(t);var s=r(28),l=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"实现promise-all"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现promise-all"}},[e._v("#")]),e._v(" 实现promise.all")]),e._v(" "),r("ul",[r("li",[e._v("实现数组中所有的promise实例都resolve之后，才resolve，否则走reject。")]),e._v(" "),r("li",[e._v("实现将promise数组中的顺序组织返回结果。")])]),e._v(" "),r("h3",{attrs:{id:"实现步骤"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现步骤"}},[e._v("#")]),e._v(" 实现步骤")]),e._v(" "),r("ol",[r("li",[e._v("创建一个新的promise实例，并且返回。为then提供")]),e._v(" "),r("li",[e._v("循环promise数组，为每一个数组绑定then方法，promise成功时候拿到resolve出来的值调用结果收集函数，其他的走reject")]),e._v(" "),r("li",[e._v("如果数组中不为promise实例，那么用这个值调用结果收集函数")]),e._v(" "),r("li",[e._v("结果收集函数组织promise实例返回的结果，当数量等于传入的数组数量时候走resolve")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Promise.all = function(arr) {\n  // 收集promise的结果成为数组\n  let result = []\n  let times = 0\n  function collectResult(y, i) {\n    result[i] = y;\n    if (++times === result.length) {\n      resolve(result)\n    }\n  }\n  return new Promise((resolve, reject) => {\n    let (i=0;i<arr.length;i++) {\n      let cur = arr[i]\n      if (isPromise(cur)) {\n        cur.then((y) => {\n          collectResult(y, i)\n        }, reject)\n      } else {\n        collectResult(cur, i)\n      }\n    }\n  })\n}\n")])])])])}),[],!1,null,null,null);t.default=l.exports}}]);